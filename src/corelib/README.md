corelib: общая библиотека моделей
=================================

## Разбор конфигурации

### Варьирование параметров

Во всех численных экспериментах нужно задавать диапазоны изменения значений параметров.
Причем часто эти диапазоны окажываются достаточно сложными. Например, в модели RFID
при значениях `Tari = 6.25us` не нужно исследовать `M = 1` или скорости больше 40 км/ч,
в то время как при других значениях `Tari` нужны и `M = 1`, и большие значения скорости.

Для реализации этого в конфигурации можно задавать диапазоны варьирования параметров.
Значение каждого параметра можно задавать в виде массива или сетки, строить декартовы
произведения всевозможных значений параметров, объединять множества параметров, строить
покомпонентные произведения или декартовы произведения целых множеств параметров.

Множества значений параметров задаются с помощью двух выражений:

- массивы (`ValArray`): определяют конечный набор значений
- сетки (`ValRange`): определяют все значения от `left` до `right` с шагом `step` (обе границы включаются).

Оба Python класса реализуют методы:

- `values()`: возвращает список из всех значений;
- `__iter__()`: позволяет использовать объекты для итерирования.
- `__len__()`
- `id`: уникальный идентификатор объекта (для каждого типа - свой счетчик)

В JSON задание диапазонов выглядит как в следующем примере, определяющем восемь комбинаций
значений параметров `"speed"` и `"m"`: 

```json
{
  "speed": {
    "op": "RANGE", 
    "args": {"left":  30, "right":  59, "step":  10}
  },
  "m": {
    "op": "ARRAY",
    "items": [2, 4]
  }
}
```

> Здесь и далее, тип операции задается в ключе "op", позиционные аргументы -  в "items",
> а именованные аргументы - в "args". Такой подход позволяет упростить сериализацию и 
> десериализацию конфигурации.

Здесь множество значений скорости - `30, 40, 50, 59`, `m` - `2, 4`. 
Результатом будут следующие комбинации:

```
(1) speed = 30, m = 2  |   (5) speed = 30, m = 4 
(2) speed = 40, m = 2  |   (6) speed = 40, m = 4 
(3) speed = 50, m = 2  |   (7) speed = 50, m = 4 
(4) speed = 59, m = 2  |   (8) speed = 59, m = 4 
```

В Python эти значения задаются так:

```python
from corelib.varvals import ValArray, ValRange

speed = ValRange(left=30, right=59, step=10)
m = ValArray([2, 4])
```

Над множествами значений параметров, которые задаются как в предыдущем примере, можно
выполнять четыре операции:

- вычислить множество (`ValSetEval`): получить множество наборов значений параметров из объекта, переданного в качестве аргумента (пример объекта - выше)
- вычислить декартово произведение множеств (`ValSetProd`)
- вычислить поэлементное произведение множеств (`ValSetZip`)
- объединить множества (`ValSetJoin`)

Все классы операций реализуют следующие методы и свойства:

- `all()`: возвращает кортеж всех значений (словарей);
- `__iter__()`: позволяет использовать объекты для итерирования.
- `__len__()`
- `id`: уникальный идентификатор объекта (для каждого типа - свой счетчик)

Пример:

```json
{
  "op": "JOIN",
  "unique": true,
  "items": [
    {
      "op": "EVAL",
      "args": {
        "speed": {
          "op": "RANGE", 
          "args": {"left":  30, "right":  50, "step":  10}
        },
        "tari": {
          "op": "ARRAY", 
          "items": ["12.5us", "18.75us"]
        },
        "m": {
          "op": "ARRAY", 
          "items": [8]
        }
      }
    }, 
    {
      "op": "PRODUCT",
      "items": [
        {
          "op": "EVAL",
          "args": {
            "speed": {
              "op": "RANGE",
              "args": {"left": 50, "right": 60, "step": 5}
            }
          }
        }, 
        {
          "op": "ZIP",
          "items": [
            {
              "op": "EVAL",
              "args":  {
                "tari": {
                  "op": "ARRAY",
                  "items": ["12.5us", "18.75us", "25.0us"]
                }    
              }
            },
            {
              "op": "EVAL",
              "args": {
                "m": {
                  "op": "ARRAY",
                  "items": [8, 4, 2]
                }
              }
            }
          ]
        }
      ]
    }
  ]
}
```

> Поле `"unique"` говорит о том, что из множества, полученного в результате применения
> операции, нужно удалить все дубликаты. 

Здесь определены 14 разных наборов параметров. Они строятся так:

```
# Для вычисления JOIN нужно вычислить его два аргумента:
# ------------------------------------------------------

    # 1. Вычисляем EVAL в JOIN.0:
    # ---------------------------
    - speed = 30, tari = 12.5us, m = 8
    - speed = 30, tari = 18.75us, m = 8
    - speed = 40, tari = 12.5us, m = 8
    - speed = 40, tari = 18.75us, m = 8
    - speed = 50, tari = 12.5us, m = 8
    - speed = 50, tari = 18.75us, m = 8

    # 2. Для вычисления vProd во втором аргументе JOIN нужно вычислить
    #    два его аргумента - EVAL и ZIP:
    # ----------------------------------------------------------------

        # 2.1 Вычисляем EVAL в JOIN.1.PROD.0:
        # --------------------------
        - speed = 50
        - speed = 55
        - speed = 60

        # 2.2 Для вычисления ZIP вычисляем его аргументы:
        # -----------------------------------------------
 
            # 2.2.1 Вычисляем EVAL в JOIN.1.PROD.1.ZIP.0:
            # -------------------------------------------
            - tari = 12.5us
            - tari = 18.75us
            - tari = 25.0us
          
            # 2.2.2 Вычисляем EVAL в JOIN.1.PROD.1.ZIP.1:
            # -------------------------------------------
            - m = 8
            - m = 4
            - m = 2
       
       # > Вычисляем ZIP в JOIN.1.PROD.1:
       # --------------------------------
       - tari = 12.5us, m = 8
       - tari = 18.75us, m = 4
       - tari = 25.0us, m = 2
    
    # > Вычисляем PROD в JOIN.1:
    # --------------------------
    - speed = 50, tari = 12.5us, m = 8
    - speed = 50, tari = 18.75us, m = 4
    - speed = 50, tari = 25.0us, m = 2
    - speed = 55, tari = 12.5us, m = 8
    - speed = 55, tari = 18.75us, m = 4
    - speed = 55, tari = 25.0us, m = 2
    - speed = 60, tari = 12.5us, m = 8
    - speed = 60, tari = 18.75us, m = 4
    - speed = 60, tari = 25.0us, m = 2

# > Вычисляем JOIN, одинаковые значения - объединяем
#   (такое значение - одно: speed = 50, tari = 12.5us, m = 8)
# -----------------------------------------------------------
- speed = 30, tari = 12.5us, m = 8
- speed = 30, tari = 18.75us, m = 8
- speed = 40, tari = 12.5us, m = 8
- speed = 40, tari = 18.75us, m = 8
- speed = 50, tari = 12.5us, m = 8
- speed = 50, tari = 18.75us, m = 8
- speed = 50, tari = 18.75us, m = 4
- speed = 50, tari = 25.0us, m = 2
- speed = 55, tari = 12.5us, m = 8
- speed = 55, tari = 18.75us, m = 4
- speed = 55, tari = 25.0us, m = 2
- speed = 60, tari = 12.5us, m = 8
- speed = 60, tari = 18.75us, m = 4
- speed = 60, tari = 25.0us, m = 2
```

> **ВАЖНО:** множества параметров не обязательно должны совпадать по ключам.
> При этом дубликаты удаляются только в том случае, если их множества ключей и
> значений (по этим ключам) полностью совпадают.
>
> При построении множества конфигураций каждая запись из множества значений параметров
> будет использоваться вместо значений параметров, заданных по-умолчанию. Поэтому ничего
> страшного, если в разных записях будут разные наборы параметров.

Вот так можно представить в Python конфигурацию, приведенную выше.


```python
from corelib.varvals import ValRange, ValArray, ValSetJoin, ValSetProd, \
    ValSetEval, ValSetZip

data = ValSetJoin(
    ValSetEval({
        "speed": ValRange(30, 50, step=10),
        "tari": ValArray(["12.5us", "18.75us"]),
        "m": ValArray([8])
    }),
    ValSetProd(
        ValSetEval({"speed": ValRange(50, 60, step=5)}),
        ValSetZip(
            ValSetEval({"tari": ValArray(["12.5us", "18.75us", "25.0us"])}),
            ValSetEval({"m": ValArray([8, 4, 2])})
        )
    ),
    unique=True
)
for record in data:
    print(record)

# {"speed": 30, "tari": "12.5us", "m": 8}
# {"speed": 30, "tari": "18.75us", "m": 8}
# ...
# {"speed": 60, "tari": "25.0us", "m": 2}
```
