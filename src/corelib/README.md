corelib: общая библиотека моделей
=================================

## Разбор конфигурации

### Варьирование параметров

Множество значений параметров можно задать с помощью специальных JSON-объектов, содержащих
записи `"vRange"` и `"vArray"`:

- `vRange`: задает сетку значений от `"left"` до `"right"` с шагом `"step"` (обе границы всегда включаются);
- `vArray`: задает массив значений

Если в объекте присутствуют и `vRange`, и `vArray`, то результатом будет объединенное множество значений.

Если при описании множества значений указываются несколько параметров, то результатом будет декартово произведение
множеств значений каждого из параметров. 

Например, следующий JSON задает 10 комбинаций значений параметров `"speed"` и `"m"`:  

```json
{
  "speed": {"vRange": {"left":  30, "right":  59, "step":  10}, "vArray":  [50, 42]},
  "m": {"vArray": [2, 4]}
}
```
Здесь множество значений скорости - `30, 40, 50, 59, 42` 
(`30, 40, 50, 59` определяются из `vRange`, а `42, 50` - из `vArray`), 
`m` - `2, 4`. Результатом будут следующие комбинации:

```
(1) speed = 30, m = 2  |   (6) speed = 30, m = 4 
(2) speed = 40, m = 2  |   (7) speed = 40, m = 4 
(3) speed = 50, m = 2  |   (8) speed = 50, m = 4 
(4) speed = 59, m = 2  |   (9) speed = 59, m = 4 
(5) speed = 42, m = 2  |  (10) speed = 42, m = 4 
```

Зачастую нет смысла рассматривать все возможные комбинации. 
Например, в модели RFID сочетание `FM0` и `Tari = 6.25us` почти всегда ведет к
вероятности идентификации автомобиля, близкой к `0`; в то же время, расчет с 
такими параметрами занимает очень много времени из-за того, что сообщений тем больше, чем
меньше `Tari` и `m`. Поэтому для определения множеств значений параметров можно использовать
операции декартова произведения множеств (`vProd`), объединения (`vJoin`) и поэлементного произведения
(`vZip`). Для вычисления множества значений аргументов, заданных непосредственно с помощью `vRange` и `vArray`,
используется элемет `vEval`.

Операции задаются объектами, каждый из которых может содержать ровно одно из следующих полей:

- `vEval`: строит множество всевозможных значений аргументов. Значением этого поля является объект с ключами-параметрами модели, значения которых - объекты с ключами `vRange` или `vArray`.
- `vProd`: строит декартово произведение значений параметров. Отличие от `vEval` в том, что значением этого поля является массив, элементы которого - объекты-операции.
- `vZip`: строит поэлементное произведение по той же логике, что и функция `zip` в Python. Как и у `vProd`, значением поля является массив с объектами-операциями.
- `vJoin`: объединяет множества значений, заданных в массиве. Одинаковые записи при этом удаляются.

Каждая операция-объект должна содержать ровно одно поле, в противном случае при разборе будет выдана ошибка.

Пример:

```json
{
  "vJoin": [
    {
      "vEval": {
        "speed": {"vRange": {"left": 30, "right": 50, "step": 10}},
        "tari": {"vArray": ["12.5us", "18.75us"]},
        "m": {"vArray": [8]}
      }
    }, 
    {
      "vProd": [
        {"vEval": {"speed": {"vRange": {"left": 50, "right": 60, "step": 5}}}}, 
        {
          "vZip": [
            {"vEval": {"tari": {"vArray": ["12.5us", "18.75us", "25.0us"]}}},
            {"vEval": {"m": { "vArray": [8, 4, 2]}}}
          ]
        }
      ]
    }
  ]
}
```

Здесь определены 14 разных наборов параметров. Они строятся так:

```
# Для вычисления vJoin нужно вычислить его два аргумента:
# -------------------------------------------------------

    # 1. Вычисляем EVAL в vJoin.0:
    # ------------------------
    - speed = 30, tari = 12.5us, m = 8
    - speed = 30, tari = 18.75us, m = 8
    - speed = 40, tari = 12.5us, m = 8
    - speed = 40, tari = 18.75us, m = 8
    - speed = 50, tari = 12.5us, m = 8
    - speed = 50, tari = 18.75us, m = 8

    # 2. Для вычисления vProd во втором аргументе vJoin нужно вычислить
    #    два его аргумента - vEval и vZip:
    # -----------------------------------------------------------------

        # 2.1 Вычисляем EVAL в vJoin.1.vProd.0:
        # --------------------------
        - speed = 50
        - speed = 55
        - speed = 60

        # 2.2 Для вычисления vZip вычисляем его аргументы:
        # ------------------------------------------------
 
            # 2.2.1 Вычисляем EVAL в vJoin.1.vProd.1.vZip.0:
            # ----------------------------------------------
            - tari = 12.5us
            - tari = 18.75us
            - tari = 25.0us
          
            # 2.2.2 Вычисляем EVAL в vJoin.1.vProd.1.vZip.1:
            # ----------------------------------------------
            - m = 8
            - m = 4
            - m = 2
       
       # > Вычисляем ZIP в vJoin.1.vProd.1:
       # ----------------------------------
       - tari = 12.5us, m = 8
       - tari = 18.75us, m = 4
       - tari = 25.0us, m = 2
    
    # > Вычисляем PROD в vJoin.1:
    # ---------------------------
    - speed = 50, tari = 12.5us, m = 8
    - speed = 50, tari = 18.75us, m = 4
    - speed = 50, tari = 25.0us, m = 2
    - speed = 55, tari = 12.5us, m = 8
    - speed = 55, tari = 18.75us, m = 4
    - speed = 55, tari = 25.0us, m = 2
    - speed = 60, tari = 12.5us, m = 8
    - speed = 60, tari = 18.75us, m = 4
    - speed = 60, tari = 25.0us, m = 2

# > Вычисляем vJoin, одинаковые значения - объединяем
#   (такое значение - одно: speed = 50, tari = 12.5us, m = 8)
# -----------------------------------------------------------
- speed = 30, tari = 12.5us, m = 8
- speed = 30, tari = 18.75us, m = 8
- speed = 40, tari = 12.5us, m = 8
- speed = 40, tari = 18.75us, m = 8
- speed = 50, tari = 12.5us, m = 8
- speed = 50, tari = 18.75us, m = 8
- speed = 50, tari = 18.75us, m = 4
- speed = 50, tari = 25.0us, m = 2
- speed = 55, tari = 12.5us, m = 8
- speed = 55, tari = 18.75us, m = 4
- speed = 55, tari = 25.0us, m = 2
- speed = 60, tari = 12.5us, m = 8
- speed = 60, tari = 18.75us, m = 4
- speed = 60, tari = 25.0us, m = 2
```

> **ВАЖНО:** множества параметров не обязательно должны совпадать по ключам.
> При этом дубликаты удаляются только в том случае, если их множества ключей и
> значений (по этим ключам) полностью совпадают.
>
> При построении множества конфигураций каждая запись из множества значений параметров
> будет использоваться вместо значений параметров, заданных по-умолчанию. Поэтому ничего
> страшного, если в разных записях будут разные наборы параметров.

В Python для представления `vArray` и `vRange` используются два класса:

- `ValArray`
- `ValRange`

Для представления операций над множествами аргументов определены следующие классы:

- `ValSetProd`
- `ValSetJoin`
- `ValSetZip`
- `ValSetEval`

Каждый из этих классов реализует метод `values(self)`, который возвращает `tuple[dict]` - 
множество значений параметров. Вычисление `values()` производится рекурсивно, как в примере выше.
