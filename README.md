# thesis-models

Модели и численные эксперименты из моей диссертации.


## Утилиты

Для каждой главы в репозитории есть несколько утилит, позволяющих выполнять
имитационные модели, производить аналитические расчеты или анализировать
результаты выполнения других программ.

- `rfidsim` - симулятор RFID, который позволяет моделировать проезды автомобилей
мимо стационарного считывателя и анализировать полученные результаты. У утилиты
есть две основные команды:
    
    - `rfidsim simulate` - выполнение имитационной модели
    - `rfidsim export` - обработка результатов предыдущих исполнений модели

- `rfidam` - аналитическая модель RFID и симулятор для ее валидации. Симулятор в
утилите `rfidam` гораздо проще, чем симулятор в `rfidsim`. В состав входят три 
команды:
    
    - `rfidam analyze` - расчет характеристик системы с помощью аналитической
    модели RFID
    - `rfidam simulate` - расчет характеристик системы с помощью упрощенной
    имитационной модели
    - `rfidam info` - расчет вероятностей тех или иных типов слотов,
    средних длительностей раундов и прочих теоретических характеристик
    - `rfidam export config vars` - показать или сохранить в CSV таблицу
    со значениями изменяемых параметров

- `qumos` - пакет для анализа систем массового обслуживания. Включает следующие
команды:

    - `qumos simulate` - выполнение имитационной модели сети массового
    обслуживания
    - `qumos analyze network` - расчет характеристик сети массового
    обслуживания c помощью аналитической модели. Для использования алгоритма
    редукции выходящих потоков нужно использовать флаг `--reduce-departed-map`.
    - `qumos analyze node` - расчет характеристик отдельной системы массового
    обслуживания
    - `qumos fit ph` - поиск PH-распределения по заданным параметрам
    - `qumos fit map` - поиск MAP-потока по заданным параметрам

- `wisim` - пакет для имитационного моделирования беспроводной сети:

    - `wisim simulate network` - имитационная модель беспроводной сети
    - `wisim simulate channel` - имитационная модель отдельного канала

- `traf` - пакет для парсинга трейсов `tcpdump` и `Wireshark`.
Позволяет извлекать последовательности интервалов и размеров пакетов.

Общие функции сгруппированы в библиотеки:

- `corelib` - самые общие функции
- `rfidlib` - библиотека общих функций для `rfidsim` и `rfidam`, включающая
форматы команд и ответов, расчет их длительностей и другие функции, связанные с
моделированием протокола EPC Class 1 Gen.2.


### RFID-симулятор `rfidsim`

Утилита `rfidsim` выполняет имитационную модель RFID, в которой моделируются     
проезды автомобилей с RFID-метками и их чтение с помощью считывателя. 
В программе есть две основные команды:

1. `rfidsim simulate` - выполнение имитационной модели.
2. `rfidsim export` - анализ результатов имитационной модели.

При выполнении первой подпрограммы результаты выполнения записываются в набор
выходных файлов, которые впоследствие можно анализировать с помощью второй 
подпрограммы. Промежуточные файлы включают логи считывателя и меток, общие 
данные о каждой промоделированной конфигурации и выборки интервалов между 
пакетами, которые считыватель передает в ЦОД.

#### Имитационная модель RFID (`rfidsim simulate`)

Формат вызова для выполнения симуляции:

```sh
> rfidsim simulate <имя конфигурации> \
    [-c|--config <JSON-файл конфигурации>] \
    [-o|--output <директория>] \
```

Если директория не указана явно, то используется папка `data` в корне проекта.

Конфигурация задается в JSON-файле, в котором должны присутствовать объект
`config.rfidsim` с основной конфигурацией модели, а также объект в массиве 
`custom`. Структура файла следующая:

```
{
    "config": {
        "rfidsim": {
            "model": {
                // здесь - значения параметров модели
            },
            "simulate": {
                // здесь - параметры симуляции, например - время остановки
            },
            "variate": {
                // в этой секции можно 
            }
    },
    "custom": [{
        "name": "имя конфигурации"^
        "config": {
            "rfidsim": {
                ...
            }
        }
    }]
}
```

Для каждого параметра конфигурация в секции `"variate"` может содержать
группу значений - массив или диапазон:

```
// Задание массива параметров:
{
    "op": "array", "dtype": DATATYPE, "values": [VAL1, VAL2, ..., VALN] 
}
// Диапазон:
{
    "type": "range", "left": MINVAL, "right": MAXVAL, "step": STEP
}
```

Если в конфигурации присутствуют групповые значения, будет построено множество
всевозможных конфигураций со значениями из этих групп, и на каждой из них будет
выполнена симуляция. Результаты каждой симуляции записываются в отдельные 
журналы, а соответствие конфигураций номерам записывается в отдельный 
json-файл.

Пример конфигурации:

```json
{
  "config": {
    "rfidsim": {
      "model": {
        "numLanes": 2,
        "laneWidth": 3.5,
        "speed": 40,
        "vehicleDirection": [1, 0, 0],
        "vehicleLength": 4,
        "vehiclePlates": ["front", "back"],
        "plateHeight": 0.5,
        "posUpdateInterval": 1e-2,
        "vehicleStartOffset": [-10.0, 0, 0],
        "vehicleLifetime": 2.0,
        "vehicleInterval": {
          "dist": "uniform",
          "args": { "min": 0.9, "max": 1.1 }
        },
        "tagModulationLoss": -10.0,
        "tagSensitivity": -18.0,
        "tagAntennaAngle": 0,
        "tagAntennaRadiationPattern": "dipole",
        "tagAntennaGain": 2.0,
        "tagAntennaPolarization": 1.0,
        "readerAntennaSides": ["front", "back"],
        "readerAntennaAngle": 45.0,
        "readerAntennaOffset": 1.0,
        "readerAntennaRadiationPattern": "dipole",
        "readerAntennaGain": 8.0,
        "readerAntennaPolarization": 0.5,
        "readerCableLoss": -1.0,
        "readerTxPower": 31.5,
        "readerCirculatorNoise": -80.0,
        "roundsPerAntenna": 1,
        "roundsPerInventoryFlag": 1,
        "sessionStrategy": "A",
        "tari": "12.5us",
        "m": 4,
        "data0Mul": 2.0,
        "rtcalMul": 2.0,
        "sl": "ALL",
        "session": "S0",
        "dr": "8",
        "trext": false,
        "q": 4,
        "frequency": 860e6,
        "powerOnInterval": 2000e-3,
        "powerOffInterval": 100e-3,
        "doppler": true,
        "thermalNoise": -114.0,
        "permittivity": 15.0,
        "conductivity": 3e-2,
        "berModel": "rayleigh"
      },
      "simulation": {
        "maxTime": 1000,
        "maxVehicles": 1000
      },
      "variate": {
        "op": "join",
        "unique": true,
        "args": [{
          "op": "eval",
          "args": {
            "speed": {"op": "range", "left": 30, "right":  50, "step":  10},
            "tari": {"op": "array", "dtype": "str", 
            "values": ["12.5us", "18.75us"]},
            "m": {"op": "array", "dtype": "int", "values": [8]}
          }
        }, 
        {
          "op": "prod",
          "items": [{
            "op": "eval",
            "args": {
              "speed": {"op": "range", "left": 50, "right": 60, "step": 5}
            }
          },         
          {
            "op": "zip",
            "args": [{
              "op": "eval",
              "args":  {
                "tari": {"op": "array", "dtype": "str", 
                "values": ["12.5us", "18.75us", "25.0us"]}
              }
            },
            {
              "op": "eval",
              "args": {
                "m": {"op": "array", "dtype": "int", "values": [8, 4, 2]}
              }
            }]
          }]
        }]
      }
    }
  },
  "custom": [
    {
      "name": "coarse",
      "config": {
        "rfidsim": {
          "simulation": {
            "maxTime": 50,
            "maxVehicles": 40
          }
        }
      }
    }
  ]
}
```

Выходные файлы из `rfidsim simulate` записываются в папку 
`data/results/rfidsim/`:

- `rfidsim_<имя конфигурации>_info.json` - информация о соответствиях между 
номером симуляции и параметрами и общая информация о симуляции;

- `rfidsim_<имя конфигурации>_<n>_vehicles.csv` - данные о сгенерированных 
автомобилях (время появления, номера, метки);

- `rfidsim_<имя конфигурации>_<n>_rounds.txt` - журнал считывателя;

- `rfidsim_<имя конфигурации>_<n>_tags.txt` - журнал меток из n-й симуляции;

- `rfidsim_<имя конфигурации>_<n>_packets.txt` - журнал отправленных 
считывателем пакетов (если задан флаг `--log-packets`).

В файле `rfidsim_<имя конфигурации>_info.json` сохраняются конкретные 
значения параметров, которые использовались при выполнении n-й симуляции, а 
также записывается общая информация  (например, сколько меток и машин было 
сгенерировано):

```js
[{
    "simulation": 1,  // номер симуляции
    "summary": {
        "numVehiclesGenerated": 100,  // сколько машин было сгенерировано
        "numVehiclesDeparted": 96,  // сколько машин успело покинуть область
        "numTagsGenerated": 200,  // сколько меток было сгенерировано
        "numTagsDeparted": 192,  // сколько меток успело покинуть область
        "numRounds": 23156,  // сколько раундов было проиграно
        "simTime": 10000,  // время на модельных часах
        "realTime": 56.8  // сколько реального времени заняла симуляция
    },
    "config": {
        // Конфигурация, в которой все параметры - скаляры.
        // Например, указано точное значение скорости:
        "rfidsim": {
            "model": {
                "speed": 60,
                // ...
            }
        }
    }
}]
```

CSV-файл с данными автомобилей имеет следующие колонки:

- `ID`: идентификатор автомобиля
- `Timestamp` - время генерации
- `FrontPlate` - номер переднего номерного знака
- `BackPlate` - номер заднего номерного знака
- `FrontEPC` - EPCID метки в переднем номере
- `FrontTID` - TID метки в переднем номере 
- `FrontTagId` - идентификатор метки в переднем номере 
- `BackEPC` - EPCID метки в заднем номере
- `BackTID` - TID метки в заднем номере 
- `BackTagId` - идентификатор метки в заднем номере

Файл с журналом считывателя `rfidsim_<имя конфигурации>_<n>_rounds.txt` содержит 
данные о каждом раунде и слоте. Про раунды записывается: когда раунд начался, 
по какой антенне происходил опрос, какая сессия использовалась.
Про слоты: номер, время начала слота и ответы, полученные от меток. Про каждый 
ответ: тип сообщения, принятая мощность в начале ответа, результат приема 
ответа и внутренний идентификатор метки.

Формат строки раунда:
```
R <номер> <время начала> A:<номер антенны> S:<номер сессии> T:<флаг опроса>
```

Формат строки слота (для удобства, задается с отступом в два пробела):
```
S <номер слота> <время начала>
```

Формат строки сообщения (с отступом в 4 пробела):
```
- <тип ответа> <мощность в начале ответа> tag:<идентификатор метки> <результат> 
```

Также в начале файла указывается ориентация антенн. Пример:
```
# Antenna 1: (0.7071, -0.7071, 0)
# Antenna 2: (-0.7071, -0.7071, 0)

...
R 123 10.580 A:1 S:0 T:A
  S 1 10.580
  S 2 10.630
    - RN16 -71.0 tag:10 ERROR
    - RN16 -69.0 tag:11 ERROR
  S 3 10.650
    - RN16 -65.0 tag:12 OK
    - EPC -62.0 tag:12 OK
    - Handle -66.0 tag:12 OK
    - Data -67.0 tag:12 OK
  S 4 10.750
    - RN16 -75.0 tag:14 OK
    - EPC -79.0 tag:14 ERROR
OFF 10.790
R 124 10.890 A:2 S:0 T:B
  S 1 10.890
...
```

Файл журнала меток `rfidsim_<имя конфигурации>_<n>_tags.txt` содержит 
информацию, когда каждая метка появилась, включалась и выключалась, как менялась 
мощность поля и как она реагировала на принятые команды.

Каждая строчка имеет следующий формат (в качестве разделителя используются 
табуляции):

```
<время> <ID метки>  <событие> <мощность> <координаты> <сообщение|состояние> \
[<параметр>=<значение>*]
```

Типы событий кодируются одной буквой:

- `A`: вход метки в область чтения
- `D`: выход метки из области чтения
- `U`: обновление положения и/или мощности поля на метке
- `R`: завершение приёма команды и выполнение действий в ответ на команду
- `T`: начало отправки ответа

При описании команд или ответов в фигурных скобках могут указываться значения 
полей. Если при изменении состояния или получении команды в метке меняются 
параметры (флаги, счетчики), то они указываются в квадратных скобках в конце. 
Возможные параметры:

- `epc`: идентификатор EPCID, указывается только при входе метки в область 
(A-строка).
- `epc`: содержимое банка TID, указывается только в A-строке.
- `ao`: вектор ориентации антенны метки.
- `s`: флаги сессий, строка длины 4, состоящая из символов `'A'` и `'B'`.
- `cnt`: счетчик числа слотов.

Все, что указывается посе символа `#`, считается комментарием.


Пример файла журнала меток:
```
...
08.000  12  A   -24.0   (10.0,0,1.75)   OFF [ao=(-1,0,0),epc=...,tid=...,s=AAAA]
...
10.000  12  U   -17.9   (4.1,0,1.75)    IDLE
...
10.580  12  R   -13.5   (4.0,0,1.75)    QUERY{S=0,T=A,Q=2}  [cnt=1]
10.667  12  R   -11.9   (3.89,0,1.75)   QREP                [cnt=0]
10.668  12  T   -11.9   (3.89,0,1.75)   RN16
10.690  12  R   -11.7   (3.6,0,1.75)    ACK
...
10.750  12  R   -11.7   (3.6,0,1.75)    QREP                [cnt=65535,s=BAAA]
...
10.790  12  U   -100.0  (2.5,0,1.75)    OFF
10.890  12  U   -11.0   (2.2,0,1.75)    IDLE                [s=AAAA]
10.900  12  R   -11.1   (2.15,0,1.75)   QUERY{S=0,T=B,Q=2}  # ignored
...
14.000  12  D   # depart
```

В файле `rfidsim_<имя конфигурации>_<n>_packets.txt` сохраняется журнал 
передачи пакетов о считанных метках. Так как сам протокол передачи данных в ЦОД 
не моделируется, здесь просто сохраняем данные о прочитанных метках и времени, 
когда они были прочитаны. Каждая строка имеет следующий формат:

```
<время> epc:<EPC> tid:<TID| - > ant:<номер антенны> rssi:<средняя мощность>
```

Пример:

```
...
10.110 epc:E0F1251234 tid:12345678 ant:1 rssi:-78.1
...
```

#### Анализ результатов моделирования RFID (`rfidsim export`)

Формат вызова для анализа результатов:

```sh
> rfidsim analyze <команда> <имя конфигурации> [-n|--number=<n>]
```

Анализатор поддерживает следующие команды:

- `rfidsim export packets intervals`: построить по журналу чтения меток 
CSV-файл с интервалами между чтениями (он содержит колонки `N` и `Interval`). 
Результат будет записан в файл `rfidsim_<имя конфигурации>_<n>_intervals.txt`.

- `rfidsim export config vars`: экспортирует в таблицу с теми параметры из 
конфигурации, которые изменяются между симцляциями, то есть те параметры, 
которые были указаны с помощью массивов или диапазонов. Названия колонок 
соответствуют самым последним ключам конфигурации, например `m`, `tari`, 
`speed`. Эта команда полезна для валидации конфигурации перед запуском 
эксперимента.

- `rfidsim export stats id`: рассчитать вероятность идентификации для каждого 
сценария. Рассчитываются вероятности идентификации отдельных меток и 
автомобилей, результат записывается в CSV-файл 
`rfidsim_<имя конфигурации>_stats_id.csv` с колонками:
  
    - `N` - номер симуляции
    - *по отдельной колонке на каждый варьируемый параметр*
    - `FrontEpcProb`
    - `BackEpcProb`
    - `FrontTidProb`
    - `BackTidProb`
    - `VehicleEpcProb`
    - `VehicleTidProb`

- `rfidsim export stats rounds`: рассчитать, в каком числе раундов 
метка в среднем принимала участие, средние длительности раундов и пр. и записать
в файл `rfidsim_<имя конфигурации>_stats_rounds.csv` со следующими колонками:

    - `N` - номер симуляции
    - *по отдельной колонке на каждый варьируемый параметр*
    - `RoundDurationMean`
    - `RoundDurationStd`
    - `NumTagsPerRoundAvg`
    - `NumRoundsPerTagAvg`
    - `EmptySlotDurationMean`
    - `CollidedSlotDurationMean`
    - `DataSlotDurationMean`
    - `AvgSuccessBER` - среднее значение BER, на котором были успешно приняты
    ответы меток



### Аналитическая модель RFID (`rfidam`)

Эта утилита реализует аналитическую модель RFID и симулятор для ее валидации. 
Симулятор в утилите `rfidam` гораздо проще, чем симулятор в `rfidsim`. 
В состав входят три команды:
    
- `rfidam analyze` - расчет характеристик системы с помощью аналитической 
модели RFID

- `rfidam simulate` - расчет характеристик системы с помощью упрощенной 
имитационной модели

- `rfidam info` - расчет вероятностей тех или иных типов слотов, 
средних длительностей раундов и прочих теоретических характеристик

Пример конфигурации:

```json
{
  "config": {
    "rfidam": {
      "model": {
        "speed": 40,
        "interval": 4.0, 
        "zoneLength": 20.0,
        "ber": 0.01,
        "scenario": "AAABx",
        "tari": "12.5us",
        "data0Mul": 2.0,
        "rtcalMul": 2.0,
        "m": 4,
        "trext": false,
        "dr": "8",
        "q": 4,
        "powerOffInterval": 100e-3,
        "useTid": true
      },
      "simulation": {
        "maxTime": 1000,
        "maxVehicles": 1000
      },
      "variate": {
        "op": "eval",
        "args": {
          "scenario": {
            "op":  "array", "dtype": "str", "values":  ["Ax", "AB", "AABBx"]
          },
          "speed": {
            "op":  "range", "left":  20, "right": 60, "step": 5
          },
          "ber": {
            "op":  "range", "left":  0.005, "right":  0.02, "step": 0.005
          },
          "useTid": {
            "op": "array", "dtype": "bool", "values": [false, true]
          }
        }
      }
    }
  },
  "custom": [{
    "name": "coarse",
    "config": {
      "rfidam": {
        "simulation": {
          "maxTime": 50,
          "maxVehicles": 40
        }
      }
    }
  }]
}
```

#### Команда `rfidam simulate`

Эта команда выполняет имитационную модель для валидации аналитического расчета.
Модель гораздо менее ресурсоемкая и менее детализированная по сравнении с
`rfidsim simulate`. В частности, она полагает, что канал имеет постоянный
BER, метки поступают с одинаковым интервалом (величина `"interval"`, указанная 
в конфигурации - расстояние между метками), а область чтения определена
предельным расстоянием (параметр `"zoneLength"`).

На выходе записывает CSV-файл `rfidam_<имя конфигурации>_sim.csv`, в котором 
содержатся колонки для всех параметров, перечисленных в секции `"variate"`
конфигурации, а также:

- `probId` - вероятность идентификации метки
- `roundDurationMean` - средняя длительность раунда инвентаризации
- `roundDurationStd` - стандартное отклонение длительности раунда
- `numActiveTagsMean` - среднее число меток, участвующих в раунде
- `numActiveTagsStd` - отклонение числа меток, участвующих в раунде


#### Команда `rfidam analyze`

Выполняет аналитический расчет характеристик системы с помощью итерационного
алгоритма. В результате работы записывает файл 
`rfidam_<имя конфигурации>_analyze.csv`, в котором содержатся колонки для всех 
параметров, перечисленных в секции `"variate"` конфигурации, а также:

- `probId` - вероятность идентификации метки
- `roundDurationMean` - средняя длительность раунда инвентаризации
- `numActiveTagsMean` - среднее число меток, участвующих в раунде
- `numIterations` - число итераций алгоритма


#### Команда `rfidam info`

Эта команда служит для расчета различных характеристик системы. У нее
есть следующие подкоманды:

- `rfidam info rounds [-n N] [-b|--ber BER] [-q Q] [--use-tid]` - 
проводит расчет раунда с помощью точной и приближенной модели для `N` 
участвующих в раунде меток. Точный расчет осуществляется методом Монте-Карло: 
моделируется размещение меток по слотам, рассчитываются вероятности потери 
отдельных ответов, длительности слотов и, в итоге, длительность раунда. Второй,
упрощенный, способ заключается в предположении о независимости определения
типов слотов, основываясь на их вероятностях (этот метод используется в 
аналитической модели). Если параметров нет, то данные берутеся из 
конфигурационного файла. Так как в нем нет явного числа меток, производится 
расчет для числа меток от 1 до `floor(zoneLength / interval)`. Результат 
записывается в файл `rfidam_info_rounds.csv`, содержащем следующие колонки:
    
    - `numTags`
    - `ber`
    - `q`
    - `useTid`
    - `roundDurationPrecise`
    - `roundDurationApprox`




### Модель сетей массового обслуживания `qumos`

Пакет для анализа систем массового обслуживания. Включает следующие
команды:

- `qumos simulate network` - выполнение имитационной модели сети массового 
обслуживания с узлами типа MAP/PH/1/N.
- `qumos simulate node` - выполнение имитационной модели одиночной системы
массового обслуживания типа MAP/PH/1/N.
- `qumos analyze network` - расчет характеристик сети массового обслуживания c 
помощью аналитической модели. Для использования алгоритма редукции выходящих 
потоков нужно использовать флаг `--reduce-departed-map`.
- `qumos analyze node` - расчет характеристик отдельной системы массового 
обслуживания
- `qumos analyze map` - расчет характеристик MAP-потока
- `qumos analyze ph` - расчет характеристик PH-распределения
- `qumos fit ph` - поиск PH-распределения по заданным параметрам
- `qumos fit map` - поиск MAP-потока по заданным параметрам
- `qumos random map` - генерация последовательности интервалов из MAP-потока
- `qumos random ph` - генерация последовательности интервалов из PH


#### Команда `qumos simulate network`

Выполняет расчет характеристик сети массового обслуживания методом Монте-Карло,
многократно разыгрывая приходы и обработки заявок.

Формат вызова:

```
qumos simulate network [-n N] [-a|--arrival ARRIVAL] 
    [-s|--service SERVICE] [-c|--capacity Q] 
    [--use-ct] [--arrival-source FILENAME] [--service-source FILENAME]
    [--max-sim-time TIME] [--max-real-time TIME] [--tol TOL]
    [-m|--arrival-mean M]   
```

Параметры модели:

- `-n, --num-hops N`: число каналов в сети

- `-a, --map MAP`: входящий поток, может быть описан четырьмя способами:
    - одним числом, интерпретируется как идентификатор записи из таблицы
      `maps.csv`;
    - строкой, содержащей ключ (столбец "Key") из таблицы `maps.csv`;
    - строкой вида `Key1:Val1,Key2:Val2,...,KeyN:ValN` - в этом случае
      поиск строки в таблице `maps.csv` будет осуществляться по набору
      ключей и их значений (например, `Algorithm:em,NumSta:2`)
    - строкой, задающей распределение, например `"exp(5)"`

- `-s, --service SERVICE`: распределение времени обслуживания. Может быть
задано одно, или же столько, сколько каналов в сети. В последнем случае, если
`-n` не указан, то число каналов определяется по числу встреченных аргументов
`-s`. Если указано одно распределение, и задано число каналов `-n N`, то
на всех станциях обслуживание будет одинаковым. Может быть задано одним
из четырех способов: 
    - одним числом, интерпретируется как идентификатор записи из таблицы
      `maps.csv`;
    - строкой, содержащей ключ (столбец "Key") из таблицы `maps.csv`;
    - строкой вида `Key1:Val1,Key2:Val2,...,KeyN:ValN` - в этом случае
      поиск строки в таблице `maps.csv` будет осуществляться по набору
      ключей и их значений (например, `Algorithm:em,NumSta:2`)
    - строкой, задающей распределение, например `"exp(5)"`

- `-c, --capacity Q`: максимальное число пакетов в очереди (емкость)

- `--use-ct`: если `--use-ct=1`, то входящий поток будет поступать на
каждый узел сети

- `--arrival-source FILENAME`: файл-каталог MAP-потоков (`maps.csv`)
- `--service-source FILENAME`: файл-каталог PH-распределений (`phs.csv`)

- `--max-sim-time T`: максимальное модельное время, по достижении которого
симуляция останавливается симуляция останавливается.

- `--max-real-time T`: максимальное реальное время, которое может быть
затрачено на симуляцию.

- `--tol TOL`: погрешность, когда измеряемые статистические параметры ее
достигают, симуляция останавливается.

- `-m, --arrival-mean M`: средний интервал между пакетами во входном потоке.
Если это число задано, то входящий поток масштабируется соответственно.
Может быть указано несколько значений `-m`.

- `-o, --output FILENAME`: куда записать результат.



#### Команда `qumos simulate node`


#### Команда `qumos analyze network`


#### Команда `qumos analyze node`


#### Команда `qumos fit ph`

Выполняет поиск PH-распределения по заданным параметрам. Команда поддерживает
несколько подкоманд:

- `qumos fit ph trace`: поиск PH-распределению по трейсу из симуляции
- `qumos fit ph moments`: поиск PH-распределения по значениям моментов
- `qumos fit ph normal`: поиск PH-приближения для нормального распределения 
- `qumos fit ph uniform`: поиск PH-приближения для равномероного распределения
- `qumos fit ph const`: поиск PH-приближения для константного распределения

Все команды поддерживают следующие аргументы:

- `--save`: флаг, указывающий, что результат нужно сохранить в файл. 
По-умолчанию, записывается в `data/qumos/ph.csv`, но файл можно
изменить с помощью аргумента `-o FILENAME`.

- `-o, --output FILENAME`: имя файла, куда нужно сохранить результат.
Если аргумент присутствует, то явно указывать `--save` не нужно.

- `-k, --key KEY`: ключ записи, по которому будет сохранен результат в файле.
- `-s, --size N`: порядок искомого PH-распределения
- `-m, --num-moments`: число моментов, которые нужно приближать, если 
используется метод моментов

- `-a, --algorithm ALGO`: алгоритм, который нужно использовать для поиска
приближенного решения. Возможные варианты: `em`, `gfit`, `opt` (`em` и `gfit` -
синонимы). EM-алгоритм нельзя использовать в команде `qumos fit ph moments`.
По-умолчанию используется EM-алгоритм, но если задача состоит в поиске 
приближения константы, по-умолчанию будет строится распределение Эрланга,
так как оно обладает наименьшим коэффициентом вариации.

Результаты выполнения могут либо быть записаны в стандартный поток вывода,
либо быть записаны в CSV-файл. Он имеет следующие столбцы:

- `ID` - номер записи
- `Time` - время создания записи
- `Key` - ключ (он передается в аргументе `-k`)
- `Params` - параметры вызова (моменты, аргуметны распределений) или имя трейса
- `Bitrate` - если используется трасса из симуляции, то сюда записывается
битрейт трафика, поступающего на станцию
- `NumSta` - если используется трасса из симуляции, то сюда записывается
число абонентских станций, использующих канал
- `SimCfg` - если используется трасса из симуляции, то сюда записывается
название конфигурации симуляции 
- `M1` - 1-й момент исходного распределения или трейса
- `M2` - 2-й момент исходного распределения или трейса
- `M3` - 3-й момент исходного распределения или трейса
- `Std` - стандартное отклонение
- `CV` - коэффициент вариации
- `Order` - порядок PH-распределения
- `NumMoments` - число приближаемых моментов
- `Algorithm` - алгоритм, который использовался для построения PH
- `Subgen` - матрица подгенератора в формате `"x11,...,x1N;...;xN1...,xNN"`
- `InitPmf` - начальное распределение в формате `"x1,...,xN"`
- `EstM1` - 1-й момент найденного PH-распределения
- `ErrM1` - ошибка в определении 1-го момента
- `EstM2` - 2-й момент найденного PH-распределения
- `ErrM2` - ошибка в определении 2-го момента
- `EstM3` - 3-й момент найденного PH-распределения
- `ErrM3` - ошибка в определении 3-го момента
- `EstStd` - стандартное отклонение PH-распределения
- `ErrStd` - ошибка в определении стандартного отклонения PH-распределения
- `EstCV` - коэффициент вариации PH-распределения
- `ErrCV` - ошибка в определении коэффициента вариации
- `Elapsed` - время, затраченное на поиск PH-распределения

Команда `qumos fit ph trace` принимает на вход трейс длительностей обслуживания, 
записанный из имитационной модели канала (`wisim simulate channel`):

```
qumos fit ph trace [ARGS] WISIM_TRACE
```

Команда `qumos fit ph moments` принимает на вход набор моментов. Если значение
`--num-moments` не указано, то используются все моменты, которые были поданы.

```
qumos fit ph moments [ARGS] M1 M2 ...
```

Команды приближения с помощью PH-распределений известных распределений 
принимают в качестве аргументов параметры этих распределений:

```
qumos fit ph normal [ARGS] [--negative ACTION] MEAN STD
qumos fit ph uniform [ARGS] MIN MAX
qumos fit ph const [ARGS] VALUE
``` 

Дополнительный аргумент `--negative ACTION` определяет, что делать с 
отрицательными значениями. Возможные варианты: `drop` - отбрасывать,
`abs` - отразить по модулю. В файл результатов будут выведены значения
моментов для фактического распределения, то есть того, которое было получено
в результате отсеивания или преобразования отрицательных значений.



#### Команда `qumos fit map`

Выполняет поиск MAP-потока по заданным параметрам. Команда поддерживает
несколько подкоманд:

- `qumos fit map rfid`: поиск MAP-потока по трейсу из симуляции `rfidsim`
- `qumos fit map pcap`: поиск MAP-потока по трейсу из Wireshark
- `qumos fit map moments`: поиск MAP-потока по значениям моментов и лагов
- `qumos fit map normal`: поиск MAP-потока для нормального распределения 
- `qumos fit map uniform`: поиск MAP-потока для равномероного распределения
- `qumos fit map const`: поиск MAP-потока для константного распределения

Все команды поддерживают следующие аргументы:

- `--save`: флаг, указывающий, что результат нужно сохранить в файл. 
По-умолчанию, записывается в `data/qumos/map.csv`, но файл можно
изменить с помощью аргумента `-o FILENAME`.

- `-o, --output FILENAME`: имя файла, куда нужно сохранить результат.
Если аргумент присутствует, то явно указывать `--save` не нужно.

- `-k, --key KEY`: ключ записи, по которому будет сохранен результат в файле.
- `-s, --size N`: порядок искомого MAP-потока
- `--num-moments`: число моментов, которые нужно приближать, если 
используется метод моментов.
- `--num-lags`: число лагов, которые нужно приблизить, если используется
метод моментов.

- `-a, --algorithm ALGO`: алгоритм, который нужно использовать для поиска
приближенного решения. Возможные варианты: `em`, `opt`, `indi`. 
EM-алгоритм нельзя использовать в команде `qumos fit map moments`.
По-умолчанию используется EM-алгоритм, но если задача состоит в поиске 
приближения константы, по-умолчанию будет строится распределение Эрланга,
так как оно обладает наименьшим коэффициентом вариации.

- `--ph-algo ALGO`: алгоритм поиска матрицы D0 (PH-распределения) для случая,
когда в качестве алгоритма восстановления MAP указан `indi` (независимый поиск
PH-распределения и, затем, поиск D1 для приближения лагов). Возможные значения
те же, что и у аргумента `--algorithm` утилиты `qumos fit ph`.

Результаты выполнения могут либо быть записаны в стандартный поток вывода,
либо быть записаны в CSV-файл. Он имеет следующие столбцы:

- `ID` - номер записи
- `Time` - время создания записи
- `Key` - ключ (он передается в аргументе `-k`)
- `Params` - параметры вызова (моменты, аргуметны распределений) или имя трейса
- `M1` - 1-й момент исходного распределения или трейса
- `M2` - 2-й момент исходного распределения или трейса
- `M3` - 3-й момент исходного распределения или трейса
- `Std` - стандартное отклонение
- `CV` - коэффициент вариации
- `L1` - лаг-1
- `L2` - лаг-2
- `Order` - порядок PH-распределения
- `NumMoments` - число приближаемых моментов
- `Algorithm` - алгоритм, который использовался для построения MAP
- `D0` - матрица D0 в формате `"x11,...,x1N;...;xN1...,xNN"`
- `D1` - матрица D1 в формате `"x11,...,x1N;...;xN1...,xNN"`
- `EstM1` - 1-й момент найденного MAP-потока
- `ErrM1` - ошибка в определении 1-го момента
- `EstM2` - 2-й момент найденного MAP-потока
- `ErrM2` - ошибка в определении 2-го момента
- `EstM3` - 3-й момент найденного MAP-потока
- `ErrM3` - ошибка в определении 3-го момента
- `EstStd` - стандартное отклонение MAP-потока
- `ErrStd` - ошибка в определении стандартного отклонения MAP-потока
- `EstCV` - коэффициент вариации MAP-потока
- `ErrCV` - ошибка в определении коэффициента вариации
- `EstL1` - лаг-1 в восстановленном MAP-потоке
- `ErrL1` - ошибка в определении лаг-1
- `EstL2` - лаг-2 в восстановленном MAP-потоке
- `ErrL2` - ошибка в определении лаг-2
- `Elapsed` - время, затраченное на поиск MAP-потока

Команда `qumos fit map rfid` принимает на вход трейс отправленных пакетов,
записанный моделью RFID (`rfidsim simulate`).

```
qumos fit map rfid [ARGS] RFIDSIM_TRACE
```

Команда `qumos fit map pcap` принимает на вход трейс, записанный Wireshark.
Рассматриваются пакеты на 2-м уровне (Ethernet), берутся интервалы между
ними и для них находится MAP-поток.

```
qumos fit map pcap [ARGS] PCAP_TRACE
```

Команда `qumos fit map moments` принимает на вход набор моментов. Если значение
`--num-moments` не указано, то используются все моменты, которые были поданы. 
Аналогично и для лагов. Каждый момент должен предваряться ключом `-m`, а лаг 
ключом`-l`.

```
qumos fit map moments [ARGS] -m M1 -m M2 ... -m MN -l L1 -l L2 ... -l LK
```

Команды приближения с помощью PH-распределений известных распределений 
принимают в качестве аргументов параметры этих распределений:

```
qumos fit map normal [ARGS] [--negative ACTION] MEAN STD
qumos fit map uniform [ARGS] MIN MAX
qumos fit map const [ARGS] VALUE
``` 

Дополнительный аргумент `--negative ACTION` определяет, что делать с 
отрицательными значениями. Возможные варианты: `drop` - отбрасывать,
`abs` - отразить по модулю. В файл результатов будут выведены значения
моментов для фактического распределения, то есть того, которое было получено
в результате отсеивания или преобразования отрицательных значений.



### Симулятор беспроводных сетей `wisim`

Пакет для имитационного моделирования беспроводной сети:

- `wisim simulate network` - имитационная модель беспроводной сети
- `wisim simulate channel` - имитационная модель отдельного канала
- `wisim analyze channel saturated` - анализ канала с помощью аналитической 
модели

По каждому пакету записывается трейс - CSV-файл с колонками, разделенными
табуляциями, со следующими колонками:

- `PacketId` - идентификатор пакета
- `Station` - станция, на которую пакет прибыл
- `ArrivedAt` - время прибытия на станцию
- `ServicedAt` - время начала обслуживания
- `DepartedAt` - время покидания станции (доставлен или отброшен)
- `PacketSize` - размер пакета, бит
- `NumAttempts` - число попыток передачи
- `Dropped` - признак того, что пакет был отброшен

#### Команда `wisim simulate network`


#### Команда `wisim simulate channel`




### Анализатор трафика `traf`





## Структура данных

```sh
data/
|- dumps/
   |- video_01.pcapng         # короткий видео файл <КАКОЙ?>, RTP-трафик
   |- video_05.pcapng         # другой видео файл <КАКОЙ> большего размера
|- traffic/
   |- intervals_video_01.csv  # CSV-файл из video_00.pcapng
   |- intervals_video_05.csv  # CSV-файл из video_01.pcapng
|- results/
   |- rfidsim/
      # Здесь оказываются все файлы, генерируемые утилитой rfidsim
   |- rfidana/
      # Здесь файлы, генерируемые rfidana


|- datasets/
   |- coarse/
      |- traffic/
         |- intervals_rfid_30.csv
         |- intervals_rfid_120.csv
         #
         # Результаты восстановления MAP-потоков для видео и RFID-трафика:
         # > qumos fit arrivals --config=coarse
         #
         |- arrivals_video_00.json
         |- arrivals_video_05.json
         |- arrivals_rfid_30.json
         |- arrivals_rfid_120.json
      |- channels/
         |- delays_dcf_video_00.csv     # > wisim channel dcf --config=coarse
         ...
         |- delays_dcf_rfid_120.csv
         |- delays_relay_video_00.csv   # > wisim channel relay --config=coarse
         ...
         |- delays_relay_rfid_120.csv
         |- service_dcf_video_00.json   # > qumos fit delays --config=coarse
         ...
         |- service_relay_rfid_120.json
      |- networks/
         |- simul_dcf_1_video_00.csv   # > wisim net dcf --config=coarse
                  # формат: simul_<тип канала>_<число станций>_<имя трафика>.csv
         ...
         |- simul_relay_10_rfid_120.csv
         |- mc_dcf_1_video_00.json     # > qumos simulate dcf --config=coarse
         ...
         |- mc_relay_10_rfid_120.json
         |- dpa_dcf_1_video_00.json    # > qumos approx --config=coarse
         ...
         |- dpa_relay_10_rfid_120.json
         |- ana_dcf_1_video_00.json    # > qumos analytic --config=coarse
         ...
         |- ana_relay_3_rfid_120.json
      |- rfidsim
         |- rounds_30.csv              # > rfidsim --config=coarse
         ...
         |- rounds_120.csv
         |- results_30.json
         ...
         |- results_120.json
      |- rfidana
         |- results_??.json             # > rfidana --config=coarse
```

## Конфигурация экспериментов

Все конфигурации хранятся в config.json. Пример конфигурации (в реальном 
json-файле комментариев нет):

```
[
    {
        "name": "coarse",  // имя конфигуркции (датасета)
        "traffic": [
            {
                "name": "low",
                "dist": "normal",
                "mean": 
            }
        ],
        "channels": {
            "dcf": {
                "bitrate": 1000,  // кбит/с
                "cwmin": 2,
                "cwmax": 16,
                "slot": 1e-9,
                "sifs": 1e-8
            }   
        }
        "config": {
            "rfidsim": {
            },
            "rfidana": {

            },
            "qumos": {

            },
            "wisim": {

            },
            "traf": {

            }
        }
    }
]
```

## Experiments




### Example of building a tcpdump:

```
> sudo tcpdump -i en0 -s 0 -nn -l -q -v -ttt > data/dump1.txt
```

### Example of sed-ing only timestamps and packet sizes from tcpdump:
```
> cat data/dump1.txt | grep '0\+:' | sed 's/00:00:00.//' | \
sed 's/\ IP\ .*\(length\)//' | sed 's/)$//'
```

### Python script for parsing pcap:

```python
from scapy.utils import RawPcapReader
from scapy.layers.l2 import Ether

def process_pcap(file_name):
    count = 0
    prev_time = 0
    data = []
    for pkt_data, pkt_metadata in RawPcapReader(file_name):
        count += 1
        ether_pkt = Ether(pkt_data)
        dt = ether_pkt.time - prev_time
        prev_time = ether_pkt.time
        data.append((ether_pkt.time, dt, pkt_metadata.wirelen))

    for record in data:
        print(record)
    print(f'Printed {count} packets')

process_pcap('data/dump1.pcapng')
```


### Live streaming with VLC:

See details [here](
https://wiki.videolan.org/Documentation:Streaming_HowTo/Command_Line_Examples/).

For RTSP (UDP streaming):

- Run the server (`input_stream` is just an .mp4 file):

```bash
% vlc -vvv input_stream --sout \
'#rtp{dst=192.168.0.12,port=1234,sdp=rtsp://server.example.org:8080/test.sdp}' 
```

- Run on the client:

```bash
% vlc rtsp://server.example.org:8080/test.sdp
```
